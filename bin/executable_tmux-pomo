#! /usr/bin/env zsh

statefile="$HOME/.pomo"
short_break=300
long_break=1800
pomo=1200
first_state=1
last_state=8

zparseopts -E -A args a=advance -advance=advance

# echo args: ${(kv)args}

function startTimerAndWriteState() {
	cntdwn -t $1 > /dev/null
	stateCnt=$2
	echo "$stateCnt" >$statefile
}

# schedule
# 0 - uninit
# 1 - 20m pomo
# 2 - 5m break
# 3 - 20m pomo
# 4 - 5m break
# 5 - 20m pomo
# 6 - 5m break
# 7 - 20m pomo
# 8 - 30m break
function advanceState() {
	(( nextState = $stateCnt + 1 ))
	if [[ $nextState -gt $last_state ]]; then
		nextState=$first_state
	fi

	(( remainder = $nextState % 2 ))
	(( stepNum = ($nextState + $remainder) / 2 ))

	if [[ $nextState -eq $last_state ]]; then
		startTimerAndWriteState $long_break $nextState
	elif [[ $remainder -eq 1 ]]; then
		startTimerAndWriteState $pomo $nextState
	else
		startTimerAndWriteState $short_break $nextState
	fi
}

function setStateName() {
	(( remainder = $stateCnt % 2 ))
	(( stepNum = ($stateCnt + $remainder) / 2 ))

	if [[ $stateCnt = 0 ]]; then
		stateName="Not started"
	elif [[ $stateCnt -eq $last_state ]]; then
		stateName="Big break"
	elif [[ $remainder -eq 1 ]]; then
		stateName="Pomo $stepNum"
	else
		stateName="Break $stepNum"
	fi
}

function printState() {
	setStateName
	print $stateName: $(cntdwn)
}

if [[ -e $statefile ]]; then
	read stateCnt <$statefile
else
	stateCnt=0
fi

if [[ -n $advance ]]; then
	if [[ $(cntdwn -e) = 0 ]]; then
		advanceState $stateCnt
	else
		print Still running
	fi
fi

printState
